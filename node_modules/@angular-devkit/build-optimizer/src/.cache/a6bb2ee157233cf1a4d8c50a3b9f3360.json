{"remainingRequest":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@syncfusion\\ej2-base\\src\\intl\\number-formatter.js","dependencies":[{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@syncfusion\\ej2-base\\src\\intl\\number-formatter.js","mtime":499162500000},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620568869347},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { isUndefined, throwError, isNullOrUndefined, extend } from '../util';\r\nimport { defaultCurrencyCode } from '../internationalization';\r\nimport { IntlBase as base } from './intl-base';\r\nimport { ParserBase as parser } from './parser-base';\r\nvar errorText = {\r\n    'ms': 'minimumSignificantDigits',\r\n    'ls': 'maximumSignificantDigits',\r\n    'mf': 'minimumFractionDigits',\r\n    'lf': 'maximumFractionDigits',\r\n};\r\nvar integerError = 'minimumIntegerDigits';\r\nvar percentSign = 'percentSign';\r\nvar minusSign = 'minusSign';\r\nvar spaceRegex = /\\s/;\r\nvar mapper = ['infinity', 'nan', 'group', 'decimal', 'exponential'];\r\nvar infinity = 'infinity';\r\nvar nan = 'nan';\r\n/**\r\n * Module for number formatting.\r\n * @private\r\n */\r\nvar NumberFormat = /** @class */ /*@__PURE__*/ (function () {\r\n    function NumberFormat() {\r\n    }\r\n    /**\r\n     * Returns the formatter function for given skeleton.\r\n     * @param {string} culture -  Specifies the culture name to be which formatting.\r\n     * @param {NumberFormatOptions} option - Specific the format in which number  will format.\r\n     * @param {Object} object- Specifies the global cldr data collection.\r\n     * @return Function.\r\n     */\r\n    NumberFormat.numberFormatter = function (culture, option, cldr) {\r\n        var _this = this;\r\n        var fOptions = extend({}, option);\r\n        var cOptions = {};\r\n        var dOptions = {};\r\n        var symbolPattern;\r\n        var dependable = base.getDependables(cldr, culture, '', true);\r\n        dOptions.numberMapper = parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr), true);\r\n        dOptions.currencySymbol = base.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode);\r\n        /* tslint:disable no-any */\r\n        dOptions.percentSymbol = dOptions.numberMapper.numberSymbols[percentSign];\r\n        dOptions.minusSymbol = dOptions.numberMapper.numberSymbols[minusSign];\r\n        var symbols = dOptions.numberMapper.numberSymbols;\r\n        if ((option.format) && !(base.formatRegex.test(option.format))) {\r\n            cOptions = base.customFormat(option.format, dOptions, dependable.numericObject);\r\n        }\r\n        else {\r\n            extend(fOptions, base.getProperNumericSkeleton(option.format || 'N'));\r\n            fOptions.isCurrency = fOptions.type === 'currency';\r\n            fOptions.isPercent = fOptions.type === 'percent';\r\n            symbolPattern = base.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);\r\n            fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);\r\n            this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);\r\n            if (!isUndefined(fOptions.fractionDigits)) {\r\n                fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;\r\n            }\r\n            if (isUndefined(fOptions.useGrouping)) {\r\n                fOptions.useGrouping = true;\r\n            }\r\n            if (fOptions.isCurrency) {\r\n                symbolPattern = symbolPattern.replace(/\\u00A4/g, base.defaultCurrency);\r\n            }\r\n            var split = symbolPattern.split(';');\r\n            cOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);\r\n            cOptions.pData = base.getFormatData(split[0], false, dOptions.currencySymbol);\r\n            if (fOptions.useGrouping) {\r\n                fOptions.groupSeparator = symbols[mapper[2]];\r\n                fOptions.groupData = this.getGroupingDetails(split[0]);\r\n            }\r\n            var minFrac = isUndefined(fOptions.minimumFractionDigits);\r\n            if (minFrac) {\r\n                fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;\r\n            }\r\n            if (isUndefined(fOptions.maximumFractionDigits)) {\r\n                var mval = cOptions.nData.maximumFraction;\r\n                fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;\r\n            }\r\n            var mfrac = fOptions.minimumFractionDigits;\r\n            var lfrac = fOptions.maximumFractionDigits;\r\n            if (!isUndefined(mfrac) && !isUndefined(lfrac)) {\r\n                if (mfrac > lfrac) {\r\n                    fOptions.maximumFractionDigits = mfrac;\r\n                }\r\n            }\r\n        }\r\n        extend(cOptions.nData, fOptions);\r\n        extend(cOptions.pData, fOptions);\r\n        return function (value) {\r\n            if (isNaN(value)) {\r\n                return symbols[mapper[1]];\r\n            }\r\n            else if (!isFinite(value)) {\r\n                return symbols[mapper[0]];\r\n            }\r\n            return _this.intNumberFormatter(value, cOptions, dOptions);\r\n        };\r\n    };\r\n    /**\r\n     * Returns grouping details for the pattern provided\r\n     * @param {string} pattern\r\n     * @returns {GroupDetails}\r\n     */\r\n    NumberFormat.getGroupingDetails = function (pattern) {\r\n        var ret = {};\r\n        var match = pattern.match(base.negativeDataRegex);\r\n        if (match && match[4]) {\r\n            var pattern_1 = match[4];\r\n            var p = pattern_1.lastIndexOf(',');\r\n            if (p !== -1) {\r\n                var temp = pattern_1.split('.')[0];\r\n                ret.primary = (temp.length - p) - 1;\r\n                var s = pattern_1.lastIndexOf(',', p - 1);\r\n                if (s !== -1) {\r\n                    ret.secondary = p - 1 - s;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Returns if the provided integer range is valid.\r\n     * @param {number} val1\r\n     * @param {number} val2\r\n     * @param {boolean} checkbothExist\r\n     * @param {boolean} isFraction\r\n     * @returns {boolean}\r\n     */\r\n    NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {\r\n        var decide = isFraction ? 'f' : 's';\r\n        var dint = 0;\r\n        var str1 = errorText['l' + decide];\r\n        var str2 = errorText['m' + decide];\r\n        if (!isUndefined(val1)) {\r\n            this.checkRange(val1, str1, isFraction);\r\n            dint++;\r\n        }\r\n        if (!isUndefined(val2)) {\r\n            this.checkRange(val2, str2, isFraction);\r\n            dint++;\r\n        }\r\n        if (dint === 2) {\r\n            if (val1 < val2) {\r\n                throwError(str2 + 'specified must be less than the' + str1);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else if (checkbothExist && dint === 1) {\r\n            throwError('Both' + str2 + 'and' + str2 + 'must be present');\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Check if the provided fraction range is valid\r\n     * @param {number} val\r\n     * @param {string} text\r\n     * @param {boolean} isFraction\r\n     * @returns {void}\r\n     */\r\n    NumberFormat.checkRange = function (val, text, isFraction) {\r\n        var range = isFraction ? [0, 20] : [1, 21];\r\n        if (val < range[0] || val > range[1]) {\r\n            throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);\r\n        }\r\n    };\r\n    /**\r\n     * Returns formatted numeric string for provided formatting options\r\n     * @param {number} value\r\n     * @param {base.GenericFormatOptions} fOptions\r\n     * @param {CommonOptions} dOptions\r\n     * @returns {string}\r\n     */\r\n    NumberFormat.intNumberFormatter = function (value, fOptions, dOptions) {\r\n        var curData;\r\n        if (isUndefined(fOptions.nData.type)) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            if (value < 0) {\r\n                value = value * -1;\r\n                curData = fOptions.nData;\r\n            }\r\n            else if (value === 0) {\r\n                curData = fOptions.zeroData || fOptions.pData;\r\n            }\r\n            else {\r\n                curData = fOptions.pData;\r\n            }\r\n            var fValue = '';\r\n            if (curData.isPercent) {\r\n                value = value * 100;\r\n            }\r\n            if (curData.groupOne) {\r\n                fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);\r\n            }\r\n            else {\r\n                fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits);\r\n                if (curData.minimumIntegerDigits) {\r\n                    fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);\r\n                }\r\n            }\r\n            if (curData.type === 'scientific') {\r\n                fValue = value.toExponential(curData.maximumFractionDigits);\r\n                fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper[4]]);\r\n            }\r\n            fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper[3]]);\r\n            if (curData.useGrouping) {\r\n                fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper[3]] || '.', curData.groupData.secondary);\r\n            }\r\n            fValue = parser.convertValueParts(fValue, base.latnParseRegex, dOptions.numberMapper.mapper);\r\n            if (curData.nlead === 'N/A') {\r\n                return curData.nlead;\r\n            }\r\n            else {\r\n                return curData.nlead + fValue + curData.nend;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns significant digits processed numeric string\r\n     * @param {number} value\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @returns {string}\r\n     */\r\n    NumberFormat.processSignificantDigits = function (value, min, max) {\r\n        var temp = value + '';\r\n        var tn;\r\n        var length = temp.length;\r\n        if (length < min) {\r\n            return value.toPrecision(min);\r\n        }\r\n        else {\r\n            temp = value.toPrecision(max);\r\n            tn = +temp;\r\n            return tn + '';\r\n        }\r\n    };\r\n    /**\r\n     * Returns grouped numeric string\r\n     * @param {string} val\r\n     * @param {number} level1\r\n     * @param {string} sep\r\n     * @param {string} decimalSymbol\r\n     * @param {number} level2\r\n     * @returns {string}\r\n     */\r\n    NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {\r\n        var flag = !isNullOrUndefined(level2) && level2 !== 0;\r\n        var split = val.split(decimalSymbol);\r\n        var prefix = split[0];\r\n        var length = prefix.length;\r\n        var str = '';\r\n        while (length > level1) {\r\n            str = prefix.slice(length - level1, length) + (str.length ?\r\n                (sep + str) : '');\r\n            length -= level1;\r\n            if (flag) {\r\n                level1 = level2;\r\n                flag = false;\r\n            }\r\n        }\r\n        split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;\r\n        return split.join(decimalSymbol);\r\n    };\r\n    /**\r\n     * Returns fraction processed numeric string\r\n     * @param {number} value\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @returns {string}\r\n     */\r\n    NumberFormat.processFraction = function (value, min, max) {\r\n        var temp = (value + '').split('.')[1];\r\n        var length = temp ? temp.length : 0;\r\n        if (min && length < min) {\r\n            var ret = '';\r\n            if (length === 0) {\r\n                ret = value.toFixed(min);\r\n            }\r\n            else {\r\n                ret += value;\r\n                for (var j = 0; j < min - length; j++) {\r\n                    ret += '0';\r\n                }\r\n                return ret;\r\n            }\r\n            return value.toFixed(min);\r\n        }\r\n        else if (!isNullOrUndefined(max) && (length > max || max === 0)) {\r\n            return value.toFixed(max);\r\n        }\r\n        return value + '';\r\n    };\r\n    /**\r\n     * Returns integer processed numeric string\r\n     * @param {string} value\r\n     * @param {number} min\r\n     * @returns {string}\r\n     */\r\n    NumberFormat.processMinimumIntegers = function (value, min) {\r\n        var temp = value.split('.');\r\n        var lead = temp[0];\r\n        var len = lead.length;\r\n        if (len < min) {\r\n            for (var i = 0; i < min - len; i++) {\r\n                lead = '0' + lead;\r\n            }\r\n            temp[0] = lead;\r\n        }\r\n        return temp.join('.');\r\n    };\r\n    return NumberFormat;\r\n}());\r\nexport { NumberFormat };\r\n",null]}