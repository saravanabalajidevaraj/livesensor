{"remainingRequest":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@syncfusion\\ej2-base\\src\\intl\\date-parser.js","dependencies":[{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@syncfusion\\ej2-base\\src\\intl\\date-parser.js","mtime":499162500000},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620568869347},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { IntlBase as base } from './intl-base';\r\nimport { ParserBase as parser } from './parser-base';\r\nimport { isUndefined, throwError, getValue, isNullOrUndefined } from '../util';\r\nimport { datePartMatcher } from './date-formatter';\r\nimport { HijriParser } from '../hijri-parser';\r\nvar number = 'numbers';\r\nvar defNoSystem = 'defaultNumberingSystem';\r\nvar noSystem = 'numberingSystem';\r\nvar standalone = 'stand-alone';\r\nvar curWeekDay = 'curWeekDay';\r\nvar latnRegex = /^[0-9]*$/;\r\nvar abbreviateRegex = /\\/MMMMM|MMMM|MMM|a|LLL|EEEEE|EEEE|E|ccc/;\r\nvar timeSetter = {\r\n    minute: 'setMinutes',\r\n    hour: 'setHours',\r\n    second: 'setSeconds',\r\n    day: 'setDate',\r\n    month: 'setMonth'\r\n};\r\nvar month = 'months';\r\n/* tslint:disable no-any */\r\n/**\r\n * Date Parser.\r\n * @private\r\n */\r\nvar DateParser = /** @class */ /*@__PURE__*/ (function () {\r\n    function DateParser() {\r\n    }\r\n    /**\r\n     * Returns the parser function for given skeleton.\r\n     * @param {string} -  Specifies the culture name to be which formatting.\r\n     * @param {DateFormatOptions} - Specific the format in which string date  will be parsed.\r\n     * @param {cldr} - Specifies the global cldr data collection.\r\n     *  @return Function.\r\n     */\r\n    // tslint:disable-next-line:max-func-body-length\r\n    DateParser.dateParser = function (culture, option, cldr) {\r\n        var _this = this;\r\n        var dependable = base.getDependables(cldr, culture, option.calendar);\r\n        var numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr));\r\n        var parseOptions = {};\r\n        var resPattern = option.format || base.getResultantPattern(option.skeleton, dependable.dateObject, option.type);\r\n        var regexString = '';\r\n        var hourOnly;\r\n        if (isUndefined(resPattern)) {\r\n            throwError('Format options or type given must be invalid');\r\n        }\r\n        else {\r\n            parseOptions = { isIslamic: base.islamicRegex.test(option.calendar), pattern: resPattern, evalposition: {} };\r\n            var patternMatch = resPattern.match(base.dateParseRegex) || [];\r\n            var length_1 = patternMatch.length;\r\n            var gmtCorrection = 0;\r\n            var zCorrectTemp = 0;\r\n            var isgmtTraversed = false;\r\n            var nRegx = numOptions.numericRegex;\r\n            var numMapper = parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr));\r\n            for (var i = 0; i < length_1; i++) {\r\n                var str = patternMatch[i];\r\n                var len = str.length;\r\n                var char = (str[0] === 'K') ? 'h' : str[0];\r\n                var isNumber = void 0;\r\n                var canUpdate = void 0;\r\n                var charKey = datePartMatcher[char];\r\n                var optional = (len === 2) ? '' : '?';\r\n                if (isgmtTraversed) {\r\n                    gmtCorrection = zCorrectTemp;\r\n                    isgmtTraversed = false;\r\n                }\r\n                switch (char) {\r\n                    case 'E':\r\n                    case 'c':\r\n                        // tslint:disable-next-line\r\n                        var weekObject = parser.reverseObject(dependable.dateObject[base.days][standalone][base.monthIndex[len]]);\r\n                        regexString += '(' + Object.keys(weekObject).join('|') + ')';\r\n                        break;\r\n                    case 'M':\r\n                    case 'L':\r\n                    case 'd':\r\n                    case 'm':\r\n                    case 's':\r\n                    case 'h':\r\n                    case 'H':\r\n                        canUpdate = true;\r\n                        if ((char === 'M' || char === 'L') && len > 2) {\r\n                            // tslint:disable-next-line\r\n                            parseOptions[charKey] = parser.reverseObject(dependable.dateObject[month][standalone][base.monthIndex[len]]);\r\n                            /* tslint:disable no-any */\r\n                            regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';\r\n                        }\r\n                        else {\r\n                            isNumber = true;\r\n                            regexString += '(' + nRegx + nRegx + optional + ')';\r\n                        }\r\n                        if (char === 'h') {\r\n                            parseOptions.hour12 = true;\r\n                        }\r\n                        break;\r\n                    case 'y':\r\n                        canUpdate = isNumber = true;\r\n                        if (len === 2) {\r\n                            regexString += '(' + nRegx + nRegx + ')';\r\n                        }\r\n                        else {\r\n                            regexString += '(' + nRegx + '{' + len + ',})';\r\n                        }\r\n                        break;\r\n                    case 'a':\r\n                        canUpdate = true;\r\n                        parseOptions[charKey] = parser.reverseObject(getValue('dayPeriods.format.wide', dependable.dateObject));\r\n                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';\r\n                        break;\r\n                    case 'G':\r\n                        canUpdate = true;\r\n                        var eText = (len <= 3) ? 'eraAbbr' : (len === 4) ? 'eraNames' : 'eraNarrow';\r\n                        parseOptions[charKey] = parser.reverseObject(getValue('eras.' + eText, dependable.dateObject));\r\n                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + '?)';\r\n                        break;\r\n                    case 'z':\r\n                        var tval = new Date().getTimezoneOffset();\r\n                        canUpdate = (tval !== 0);\r\n                        parseOptions[charKey] = getValue('dates.timeZoneNames', dependable.parserObject);\r\n                        var tzone = parseOptions[charKey];\r\n                        hourOnly = (len < 4);\r\n                        var hpattern = hourOnly ? '+H;-H' : tzone.hourFormat;\r\n                        hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);\r\n                        regexString += '(' + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ')?';\r\n                        isgmtTraversed = true;\r\n                        zCorrectTemp = hourOnly ? 6 : 12;\r\n                        break;\r\n                    case '\\'':\r\n                        var iString = str.replace(/\\'/g, '');\r\n                        regexString += '(' + iString + ')?';\r\n                        break;\r\n                    default:\r\n                        regexString += '([\\\\D])';\r\n                        break;\r\n                }\r\n                if (canUpdate) {\r\n                    parseOptions.evalposition[charKey] = { isNumber: isNumber, pos: i + 1 + gmtCorrection, hourOnly: hourOnly };\r\n                }\r\n                if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {\r\n                    parseOptions.parserRegex = new RegExp('^' + regexString + '$');\r\n                }\r\n            }\r\n        }\r\n        return function (value) {\r\n            var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);\r\n            if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {\r\n                return null;\r\n            }\r\n            if (parseOptions.isIslamic) {\r\n                var dobj = {};\r\n                var tYear = parsedDateParts.year;\r\n                var tDate = parsedDateParts.day;\r\n                var tMonth = parsedDateParts.month;\r\n                var ystrig = tYear ? (tYear + '') : '';\r\n                var is2DigitYear = (ystrig.length === 2);\r\n                if (!tYear || !tMonth || !tDate || is2DigitYear) {\r\n                    dobj = HijriParser.getHijriDate(new Date());\r\n                }\r\n                if (is2DigitYear) {\r\n                    tYear = parseInt((dobj.year + '').slice(0, 2) + ystrig, 10);\r\n                }\r\n                // tslint:disable-next-line\r\n                var dateObject = HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);\r\n                parsedDateParts.year = dateObject.getFullYear();\r\n                parsedDateParts.month = dateObject.getMonth() + 1;\r\n                parsedDateParts.day = dateObject.getDate();\r\n            }\r\n            return _this.getDateObject(parsedDateParts);\r\n        };\r\n    };\r\n    /* tslint:disable */\r\n    /**\r\n     * Returns date object for provided date options\r\n     * @param {DateParts} options\r\n     * @param {Date} value\r\n     * @returns {Date}\r\n     */\r\n    DateParser.getDateObject = function (options, value) {\r\n        var res = value || new Date();\r\n        res.setMilliseconds(0);\r\n        var tKeys = ['hour', 'minute', 'second', 'month', 'day'];\r\n        var y = options.year;\r\n        var desig = options.designator;\r\n        var tzone = options.timeZone;\r\n        if (!isUndefined(y)) {\r\n            var len = (y + '').length;\r\n            if (len <= 2) {\r\n                var century = Math.floor(res.getFullYear() / 100) * 100;\r\n                y += century;\r\n            }\r\n            res.setFullYear(y);\r\n        }\r\n        for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {\r\n            var key = tKeys_1[_i];\r\n            var tValue = options[key];\r\n            if (!isUndefined(tValue)) {\r\n                if (key === 'month') {\r\n                    tValue -= 1;\r\n                    if (tValue < 0 || tValue > 11) {\r\n                        return new Date('invalid');\r\n                    }\r\n                    var pDate = res.getDate();\r\n                    res.setDate(1);\r\n                    res[timeSetter[key]](tValue);\r\n                    var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();\r\n                    res.setDate(pDate < lDate ? pDate : lDate);\r\n                }\r\n                else {\r\n                    if (key === 'day') {\r\n                        var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();\r\n                        if ((tValue < 1 || tValue > lastDay)) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                    res[timeSetter[key]](tValue);\r\n                }\r\n            }\r\n        }\r\n        if (!isUndefined(desig)) {\r\n            var hour = res.getHours();\r\n            if (desig === 'pm') {\r\n                res.setHours(hour + (hour === 12 ? 0 : 12));\r\n            }\r\n            else if (hour === 12) {\r\n                res.setHours(0);\r\n            }\r\n        }\r\n        if (!isUndefined(tzone)) {\r\n            var tzValue = tzone - res.getTimezoneOffset();\r\n            if (tzValue !== 0) {\r\n                res.setMinutes(res.getMinutes() + tzValue);\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns date parsing options for provided value along with parse and numeric options\r\n     * @param {string} value\r\n     * @param {ParseOptions} parseOptions\r\n     * @param {NumericOptions} num\r\n     * @returns {DateParts}\r\n     */\r\n    DateParser.internalDateParse = function (value, parseOptions, num) {\r\n        var matches = value.match(parseOptions.parserRegex);\r\n        var retOptions = { 'hour': 0, 'minute': 0, 'second': 0 };\r\n        var nRegx = num.numericRegex;\r\n        if (isNullOrUndefined(matches)) {\r\n            return null;\r\n        }\r\n        else {\r\n            var props = Object.keys(parseOptions.evalposition);\r\n            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\r\n                var prop = props_1[_i];\r\n                var curObject = parseOptions.evalposition[prop];\r\n                var matchString = matches[curObject.pos];\r\n                if (curObject.isNumber) {\r\n                    retOptions[prop] = this.internalNumberParser(matchString, num);\r\n                }\r\n                else {\r\n                    if (prop === 'timeZone' && !isUndefined(matchString)) {\r\n                        var pos = curObject.pos;\r\n                        var val = void 0;\r\n                        var tmatch = matches[pos + 1];\r\n                        var flag = !isUndefined(tmatch);\r\n                        if (curObject.hourOnly) {\r\n                            val = this.getZoneValue(flag, tmatch, matches[pos + 4], num) * 60;\r\n                        }\r\n                        else {\r\n                            val = this.getZoneValue(flag, tmatch, matches[pos + 7], num) * 60;\r\n                            val += this.getZoneValue(flag, matches[pos + 4], matches[pos + 10], num);\r\n                        }\r\n                        if (!isNullOrUndefined(val)) {\r\n                            retOptions[prop] = val;\r\n                        }\r\n                    }\r\n                    else {\r\n                        retOptions[prop] = parseOptions[prop][matchString];\r\n                    }\r\n                }\r\n            }\r\n            if (parseOptions.hour12) {\r\n                retOptions.hour12 = true;\r\n            }\r\n        }\r\n        return retOptions;\r\n    };\r\n    /**\r\n     * Returns parsed number for provided Numeric string and Numeric Options\r\n     * @param {string} value\r\n     * @param {NumericOptions} option\r\n     * @returns {number}\r\n     */\r\n    DateParser.internalNumberParser = function (value, option) {\r\n        value = parser.convertValueParts(value, option.numberParseRegex, option.numericPair);\r\n        if (latnRegex.test(value)) {\r\n            return +value;\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns parsed time zone RegExp for provided hour format and time zone\r\n     * @param {string} hourFormat\r\n     * @param {base.TimeZoneOptions} tZone\r\n     * @param {string} nRegex\r\n     * @returns {string}\r\n     */\r\n    DateParser.parseTimeZoneRegx = function (hourFormat, tZone, nRegex) {\r\n        var pattern = tZone.gmtFormat;\r\n        var ret;\r\n        var result;\r\n        var cRegex = '(' + nRegex + ')' + '(' + nRegex + ')';\r\n        var splitStr;\r\n        ret = hourFormat.replace('+', '\\\\+');\r\n        if (hourFormat.indexOf('HH') !== -1) {\r\n            ret = ret.replace(/HH|mm/g, '(' + cRegex + ')');\r\n        }\r\n        else {\r\n            ret = ret.replace(/H|m/g, '(' + cRegex + '?)');\r\n        }\r\n        splitStr = (ret.split(';').map(function (str) {\r\n            return pattern.replace('{0}', str);\r\n        }));\r\n        ret = splitStr.join('|') + '|' + tZone.gmtZeroFormat;\r\n        return ret;\r\n    };\r\n    /**\r\n     * Returns zone based value.\r\n     * @param {boolean} flag\r\n     * @param {string} val1\r\n     * @param {string} val2\r\n     * @param {NumericOptions} num\r\n     * @returns {number}\r\n     */\r\n    DateParser.getZoneValue = function (flag, val1, val2, num) {\r\n        var ival = flag ? val1 : val2;\r\n        if (!ival) {\r\n            return 0;\r\n        }\r\n        var value = this.internalNumberParser(ival, num);\r\n        if (flag) {\r\n            return -value;\r\n        }\r\n        return value;\r\n    };\r\n    return DateParser;\r\n}());\r\nexport { DateParser };\r\n/* tslint:enable */\r\n",null]}