{"remainingRequest":"D:\\xampp\\htdocs\\sensorsecurity\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\xampp\\htdocs\\sensorsecurity\\node_modules\\@syncfusion\\ej2-base\\src\\intl\\number-parser.js","dependencies":[{"path":"D:\\xampp\\htdocs\\sensorsecurity\\node_modules\\@syncfusion\\ej2-base\\src\\intl\\number-parser.js","mtime":499162500000},{"path":"D:\\xampp\\htdocs\\sensorsecurity\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620568869347},{"path":"D:\\xampp\\htdocs\\sensorsecurity\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { extend, isNullOrUndefined } from '../util';\r\nimport { ParserBase as parser } from './parser-base';\r\nimport { IntlBase as base } from './intl-base';\r\nvar formatRegex = /(^[ncpa]{1})([0-1]?[0-9]|20)?$/i;\r\nvar parseRegex = /^([^0-9]*)(([0-9,]*[0-9]+)(\\.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$/;\r\nvar groupRegex = /,/g;\r\nvar latnDecimalRegex = /^[0-9]*(\\.[0-9]+)?$/;\r\nvar keys = ['minusSign', 'infinity'];\r\n/**\r\n * Module for Number Parser.\r\n * @private\r\n */\r\nvar NumberParser = /** @class */ /*@__PURE__*/ (function () {\r\n    function NumberParser() {\r\n    }\r\n    /**\r\n     * Returns the parser function for given skeleton.\r\n     * @param {string} -  Specifies the culture name to be which formatting.\r\n     * @param {NumberFormatOptions} - Specific the format in which number  will parsed.\r\n     * @param {cldr} - Specifies the global cldr data collection.\r\n     * @return Function.\r\n     */\r\n    NumberParser.numberParser = function (culture, option, cldr) {\r\n        var _this = this;\r\n        var dependable = base.getDependables(cldr, culture, '', true);\r\n        var parseOptions = { custom: true };\r\n        var numOptions;\r\n        if ((base.formatRegex.test(option.format)) || !(option.format)) {\r\n            extend(parseOptions, base.getProperNumericSkeleton(option.format || 'N'));\r\n            parseOptions.custom = false;\r\n        }\r\n        else {\r\n            extend(parseOptions, base.customFormat(option.format, null, null));\r\n        }\r\n        numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr), true);\r\n        parseOptions.symbolRegex = parser.getSymbolRegex(Object.keys(numOptions.symbolMatch));\r\n        // tslint:disable-next-line:no-any\r\n        parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];\r\n        var symbolpattern = base.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);\r\n        if (symbolpattern) {\r\n            symbolpattern = symbolpattern.replace(/\\u00A4/g, base.defaultCurrency);\r\n            var split = symbolpattern.split(';');\r\n            parseOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, '');\r\n            parseOptions.pData = base.getFormatData(split[0], true, '');\r\n        }\r\n        return function (value) {\r\n            return _this.getParsedNumber(value, parseOptions, numOptions);\r\n        };\r\n    };\r\n    /**\r\n     * Returns parsed number for the provided formatting options\r\n     * @param {string} value\r\n     * @param {NumericParts} options\r\n     * @param {NumericOptions} numOptions\r\n     * @returns {number}\r\n     */\r\n    NumberParser.getParsedNumber = function (value, options, numOptions) {\r\n        var isNegative;\r\n        var isPercent;\r\n        var tempValue;\r\n        var lead;\r\n        var end;\r\n        var ret;\r\n        if (value.indexOf(options.infinity) !== -1) {\r\n            return Infinity;\r\n        }\r\n        else {\r\n            value = parser.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);\r\n            value = parser.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);\r\n            if (value.indexOf('.') === 0) {\r\n                value = '0' + value;\r\n            }\r\n            var matches = value.match(parseRegex);\r\n            if (isNullOrUndefined(matches)) {\r\n                return NaN;\r\n            }\r\n            lead = matches[1];\r\n            tempValue = matches[2];\r\n            var exponent = matches[5];\r\n            end = matches[6];\r\n            isNegative = options.custom ? ((lead === options.nData.nlead) && (end === options.nData.nend)) :\r\n                ((lead.indexOf(options.nData.nlead) !== -1) && (end.indexOf(options.nData.nend) !== -1));\r\n            isPercent = isNegative ?\r\n                options.nData.isPercent :\r\n                options.pData.isPercent;\r\n            tempValue = tempValue.replace(groupRegex, '');\r\n            if (exponent) {\r\n                tempValue += exponent;\r\n            }\r\n            ret = +tempValue;\r\n            if (options.type === 'percent' || isPercent) {\r\n                ret = ret / 100;\r\n            }\r\n            if (options.custom || options.fractionDigits) {\r\n                ret = parseFloat(ret.toFixed(options.custom ?\r\n                    (isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits) : options.fractionDigits));\r\n            }\r\n            if (isNegative) {\r\n                ret *= -1;\r\n            }\r\n            return ret;\r\n        }\r\n    };\r\n    return NumberParser;\r\n}());\r\nexport { NumberParser };\r\n",null]}