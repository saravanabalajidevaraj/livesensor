{"remainingRequest":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\ngx-cacheable\\dist\\cacheable.decorator.js","dependencies":[{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\ngx-cacheable\\dist\\cacheable.decorator.js","mtime":1538566527000},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620568869347},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\nvar DEFAULT_CACHE_RESOLVER = function (oldParams, newParams) {\n    return JSON.stringify(oldParams) === JSON.stringify(newParams);\n};\nfunction Cacheable(_cacheConfig) {\n    return function (_target, _propertyKey, propertyDescriptor) {\n        var _oldMethod = propertyDescriptor.value;\n        if (propertyDescriptor && propertyDescriptor.value) {\n            var _cachePairs_1 = [];\n            var _observableCachePairs_1 = [];\n            var cacheConfig_1 = _cacheConfig ? _cacheConfig : {};\n            if (cacheConfig_1.cacheBusterObserver) {\n                /**\n                 * subscribe to the cacheBusterObserver and upon emission, clear all caches\n                 */\n                cacheConfig_1.cacheBusterObserver.subscribe(function (_) {\n                    _cachePairs_1.length = 0;\n                    _observableCachePairs_1.length = 0;\n                });\n            }\n            cacheConfig_1.cacheResolver = cacheConfig_1.cacheResolver\n                ? cacheConfig_1.cacheResolver\n                : DEFAULT_CACHE_RESOLVER;\n            /* use function instead of an arrow function to keep context of invocation */\n            propertyDescriptor.value = function () {\n                var _parameters = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    _parameters[_i] = arguments[_i];\n                }\n                var parameters = JSON.parse(JSON.stringify(_parameters));\n                var _foundCachePair = _cachePairs_1.find(function (cp) {\n                    return cacheConfig_1.cacheResolver(cp.parameters, parameters);\n                });\n                var _foundObservableCachePair = _observableCachePairs_1.find(function (cp) {\n                    return cacheConfig_1.cacheResolver(cp.parameters, parameters);\n                });\n                /**\n                 * check if maxAge is passed and cache has actually expired\n                 */\n                if (cacheConfig_1.maxAge && _foundCachePair && _foundCachePair.created) {\n                    if (new Date().getTime() - _foundCachePair.created.getTime() >\n                        cacheConfig_1.maxAge) {\n                        /**\n                         * cache duration has expired - remove it from the cachePairs array\n                         */\n                        _cachePairs_1.splice(_cachePairs_1.indexOf(_foundCachePair), 1);\n                        _foundCachePair = null;\n                    }\n                    else if (_cacheConfig.slidingExpiration) {\n                        /**\n                         * renew cache duration\n                         */\n                        _foundCachePair.created = new Date();\n                    }\n                }\n                if (_foundCachePair) {\n                    var cached$ = rxjs_1.of(_foundCachePair.response);\n                    return cacheConfig_1.async ? cached$.pipe(operators_1.delay(0)) : cached$;\n                }\n                else if (_foundObservableCachePair) {\n                    return _foundObservableCachePair.response;\n                }\n                else {\n                    var response$ = _oldMethod.call.apply(_oldMethod, [this].concat(parameters)).pipe(operators_1.finalize(function () {\n                        /**\n                         * if there has been an observable cache pair for these parameters, when it completes or errors, remove it\n                         */\n                        var _observableCachePairToRemove = _observableCachePairs_1.find(function (cp) { return cacheConfig_1.cacheResolver(cp.parameters, parameters); });\n                        _observableCachePairs_1.splice(_observableCachePairs_1.indexOf(_observableCachePairToRemove), 1);\n                    }), operators_1.tap(function (response) {\n                        /**\n                         * if no maxCacheCount has been passed\n                         * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n                         * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n                         */\n                        if (!cacheConfig_1.shouldCacheDecider ||\n                            cacheConfig_1.shouldCacheDecider(response)) {\n                            if (!cacheConfig_1.maxCacheCount ||\n                                cacheConfig_1.maxCacheCount === 1 ||\n                                (cacheConfig_1.maxCacheCount &&\n                                    cacheConfig_1.maxCacheCount < _cachePairs_1.length + 1)) {\n                                _cachePairs_1.shift();\n                            }\n                            _cachePairs_1.push({\n                                parameters: parameters,\n                                response: response,\n                                created: cacheConfig_1.maxAge ? new Date() : null\n                            });\n                        }\n                    }), \n                    /**\n                     * replay cached observable, so we don't enter finalize and tap for every cached observable subscription\n                     */\n                    operators_1.shareReplay());\n                    /**\n                     * cache the stream\n                     */\n                    _observableCachePairs_1.push({\n                        parameters: parameters,\n                        response: response$,\n                        created: new Date()\n                    });\n                    return response$;\n                }\n            };\n        }\n        return propertyDescriptor;\n    };\n}\nexports.Cacheable = Cacheable;\n//# sourceMappingURL=cacheable.decorator.js.map",null]}