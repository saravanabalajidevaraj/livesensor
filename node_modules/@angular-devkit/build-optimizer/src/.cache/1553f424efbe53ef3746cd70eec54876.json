{"remainingRequest":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@syncfusion\\ej2-base\\src\\canvas-renderer.js","dependencies":[{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@syncfusion\\ej2-base\\src\\canvas-renderer.js","mtime":499162500000},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620568869347},{"path":"D:\\xampp\\htdocs\\live-security-web-app1\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\r\n * To import utils\r\n */\r\nimport { isNullOrUndefined } from './util';\r\n/**\r\n * @private\r\n */\r\nvar CanvasRenderer = /** @class */ /*@__PURE__*/ (function () {\r\n    /* End-Properties */\r\n    function CanvasRenderer(rootID) {\r\n        this.rootId = rootID;\r\n    }\r\n    // method to get the attributes value\r\n    /* tslint:disable */\r\n    CanvasRenderer.prototype.getOptionValue = function (options, key) {\r\n        return options[key];\r\n    };\r\n    /* tslint:enable */\r\n    /**\r\n     * To create a Html5 canvas element\r\n     * @param {BaseAttibutes} options - Options to create canvas\r\n     * @return {HTMLCanvasElement}\r\n     */\r\n    CanvasRenderer.prototype.createCanvas = function (options) {\r\n        var canvasObj = document.createElement('canvas');\r\n        canvasObj.setAttribute('id', this.rootId + '_canvas');\r\n        this.ctx = canvasObj.getContext('2d');\r\n        this.canvasObj = canvasObj;\r\n        this.setCanvasSize(options.width, options.height);\r\n        return this.canvasObj;\r\n    };\r\n    /**\r\n     * To set the width and height for the Html5 canvas element\r\n     * @param {number} width - width of the canvas\r\n     * @param {number} height - height of the canvas\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.setCanvasSize = function (width, height) {\r\n        var element = document.getElementById(this.rootId);\r\n        var size = !isNullOrUndefined(element) ? element.getBoundingClientRect() : null;\r\n        if (isNullOrUndefined(this.width)) {\r\n            this.canvasObj.setAttribute('width', width ? width.toString() : size.width.toString());\r\n        }\r\n        else {\r\n            this.canvasObj.setAttribute('width', this.width.toString());\r\n        }\r\n        if (isNullOrUndefined(this.height)) {\r\n            this.canvasObj.setAttribute('height', height ? height.toString() : '450');\r\n        }\r\n        else {\r\n            this.canvasObj.setAttribute('height', this.height.toString());\r\n        }\r\n    };\r\n    // To set the values to the attributes\r\n    CanvasRenderer.prototype.setAttributes = function (options) {\r\n        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\r\n        var dashArray = this.getOptionValue(options, 'stroke-dasharray');\r\n        if (!isNullOrUndefined(dashArray)) {\r\n            var dashArrayString = dashArray.split(',');\r\n            this.ctx.setLineDash([parseInt(dashArrayString[0], 10), parseInt(dashArrayString[1], 10)]);\r\n        }\r\n        this.ctx.strokeStyle = this.getOptionValue(options, 'stroke');\r\n    };\r\n    /**\r\n     * To draw a line\r\n     * @param {LineAttributes} options - required options to draw a line on the canvas\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawLine = function (options) {\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\r\n        this.ctx.strokeStyle = options.stroke;\r\n        this.ctx.moveTo(options.x1, options.y1);\r\n        this.ctx.lineTo(options.x2, options.y2);\r\n        this.ctx.stroke();\r\n        this.ctx.restore();\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw a rectangle\r\n     * @param {RectAttributes} options - required options to draw a rectangle on the canvas\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawRectangle = function (options) {\r\n        var canvasCtx = this.ctx;\r\n        var cornerRadius = options.rx;\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.globalAlpha = this.getOptionValue(options, 'opacity');\r\n        this.setAttributes(options);\r\n        this.ctx.rect(options.x, options.y, options.width, options.height);\r\n        if (cornerRadius !== null && cornerRadius >= 0) {\r\n            this.drawCornerRadius(options);\r\n        }\r\n        else {\r\n            if (options.fill === 'none') {\r\n                options.fill = 'transparent';\r\n            }\r\n            this.ctx.fillStyle = options.fill;\r\n            this.ctx.fillRect(options.x, options.y, options.width, options.height);\r\n            this.ctx.stroke();\r\n        }\r\n        this.ctx.restore();\r\n        this.ctx = canvasCtx;\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    // To draw the corner of a rectangle\r\n    CanvasRenderer.prototype.drawCornerRadius = function (options) {\r\n        var cornerRadius = options.rx;\r\n        var x = options.x;\r\n        var y = options.y;\r\n        var width = options.width;\r\n        var height = options.height;\r\n        if (options.fill === 'none') {\r\n            options.fill = 'transparent';\r\n        }\r\n        this.ctx.fillStyle = options.fill;\r\n        if (width < 2 * cornerRadius) {\r\n            cornerRadius = width / 2;\r\n        }\r\n        if (height < 2 * cornerRadius) {\r\n            cornerRadius = height / 2;\r\n        }\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(x + width - cornerRadius, y);\r\n        this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);\r\n        this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);\r\n        this.ctx.arcTo(x, y + height, x, y, cornerRadius);\r\n        this.ctx.arcTo(x, y, x + width, y, cornerRadius);\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n        this.ctx.stroke();\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw a path on the canvas\r\n     * @param {PathAttributes} options - options needed to draw path\r\n     * @param {Int32Array} canvasTranslate - Array of numbers to translate the canvas\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawPath = function (options, canvasTranslate) {\r\n        var path = options.d;\r\n        var dataSplit = path.split(' ');\r\n        var borderWidth = this.getOptionValue(options, 'stroke-width');\r\n        var canvasCtx = this.ctx;\r\n        var flag = true;\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        if (canvasTranslate) {\r\n            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);\r\n        }\r\n        this.ctx.globalAlpha = options.opacity ? options.opacity : this.getOptionValue(options, 'fill-opacity');\r\n        this.setAttributes(options);\r\n        for (var i = 0; i < dataSplit.length; i = i + 3) {\r\n            var x1 = parseFloat(dataSplit[i + 1]);\r\n            var y1 = parseFloat(dataSplit[i + 2]);\r\n            switch (dataSplit[i]) {\r\n                case 'M':\r\n                    if (!options.innerR && !options.cx) {\r\n                        this.ctx.moveTo(x1, y1);\r\n                    }\r\n                    break;\r\n                case 'L':\r\n                    if (!options.innerR) {\r\n                        this.ctx.lineTo(x1, y1);\r\n                    }\r\n                    break;\r\n                case 'C':\r\n                    var c1 = parseFloat(dataSplit[i + 3]);\r\n                    var c2 = parseFloat(dataSplit[i + 4]);\r\n                    var c3 = parseFloat(dataSplit[i + 5]);\r\n                    var c4 = parseFloat(dataSplit[i + 6]);\r\n                    this.ctx.bezierCurveTo(x1, y1, c1, c2, c3, c4);\r\n                    i = i + 4;\r\n                    break;\r\n                case 'A':\r\n                    if (!options.innerR) {\r\n                        if (options.cx) {\r\n                            this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);\r\n                        }\r\n                        else {\r\n                            this.ctx.moveTo(options.x, options.y);\r\n                            this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);\r\n                            this.ctx.lineTo(options.x, options.y);\r\n                        }\r\n                    }\r\n                    else if (flag) {\r\n                        this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);\r\n                        this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);\r\n                        flag = false;\r\n                    }\r\n                    i = i + 5;\r\n                    break;\r\n                case 'z':\r\n                    this.ctx.closePath();\r\n                    break;\r\n            }\r\n        }\r\n        if (options.fill !== 'none' && options.fill !== undefined) {\r\n            this.ctx.fillStyle = options.fill;\r\n            this.ctx.fill();\r\n        }\r\n        if (borderWidth > 0) {\r\n            this.ctx.stroke();\r\n        }\r\n        this.ctx.restore();\r\n        this.ctx = canvasCtx;\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw a text\r\n     * @param {TextAttributes} options - options required to draw text\r\n     * @param {string} label - Specifies the text which has to be drawn on the canvas\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawText = function (options, label) {\r\n        var fontWeight = this.getOptionValue(options, 'font-weight');\r\n        if (!isNullOrUndefined(fontWeight) && fontWeight.toLowerCase() === 'regular') {\r\n            fontWeight = 'normal';\r\n        }\r\n        var fontSize = this.getOptionValue(options, 'font-size');\r\n        var fontFamily = this.getOptionValue(options, 'font-family');\r\n        var fontStyle = this.getOptionValue(options, 'font-style').toLowerCase();\r\n        var font = (fontStyle + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily);\r\n        var anchor = this.getOptionValue(options, 'text-anchor');\r\n        var opacity = options.opacity !== undefined ? options.opacity : 1;\r\n        if (anchor === 'middle') {\r\n            anchor = 'center';\r\n        }\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = options.fill;\r\n        this.ctx.font = font;\r\n        this.ctx.textAlign = anchor;\r\n        this.ctx.globalAlpha = opacity;\r\n        if (options.baseline) {\r\n            this.ctx.textBaseline = options.baseline;\r\n        }\r\n        var txtlngth = 0;\r\n        this.ctx.translate(options.x + (txtlngth / 2), options.y);\r\n        this.ctx.rotate(options.labelRotation * Math.PI / 180);\r\n        this.ctx.fillText(label, 0, 0);\r\n        this.ctx.restore();\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw circle on the canvas\r\n     * @param {CircleAttributes} options - required options to draw the circle\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawCircle = function (options) {\r\n        var canvasCtx = this.ctx;\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);\r\n        this.ctx.fillStyle = options.fill;\r\n        this.ctx.globalAlpha = options.opacity;\r\n        this.ctx.fill();\r\n        this.setAttributes(options);\r\n        this.ctx.stroke();\r\n        this.ctx.restore();\r\n        this.ctx = canvasCtx;\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw polyline\r\n     * @param {PolylineAttributes} options - options needed to draw polyline\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawPolyline = function (options) {\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        var points = options.points.split(' ');\r\n        for (var i = 0; i < points.length - 1; i++) {\r\n            var point = points[i].split(',');\r\n            var x = parseFloat(point[0]);\r\n            var y = parseFloat(point[1]);\r\n            if (i === 0) {\r\n                this.ctx.moveTo(x, y);\r\n            }\r\n            else {\r\n                this.ctx.lineTo(x, y);\r\n            }\r\n        }\r\n        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\r\n        this.ctx.strokeStyle = options.stroke;\r\n        this.ctx.stroke();\r\n        this.ctx.restore();\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw an ellipse on the canvas\r\n     * @param {EllipseAttributes} options - options needed to draw ellipse\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawEllipse = function (options) {\r\n        var canvasCtx = this.ctx;\r\n        var circumference = Math.max(options.rx, options.ry);\r\n        var scaleX = options.rx / circumference;\r\n        var scaleY = options.ry / circumference;\r\n        this.ctx.save();\r\n        this.ctx.beginPath();\r\n        this.ctx.translate(options.cx, options.cy);\r\n        this.ctx.save();\r\n        this.ctx.scale(scaleX, scaleY);\r\n        this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);\r\n        this.ctx.fillStyle = options.fill;\r\n        this.ctx.fill();\r\n        this.ctx.restore();\r\n        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\r\n        this.ctx.strokeStyle = options.stroke;\r\n        this.ctx.stroke();\r\n        this.ctx.restore();\r\n        this.ctx = canvasCtx;\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To draw an image\r\n     * @param {ImageAttributes} options - options required to draw an image on the canvas\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.drawImage = function (options) {\r\n        this.ctx.save();\r\n        var imageObj = new Image();\r\n        if (!isNullOrUndefined(options.href)) {\r\n            imageObj.src = options.href;\r\n            this.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);\r\n        }\r\n        this.ctx.restore();\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n    };\r\n    /**\r\n     * To create a linear gradient\r\n     * @param {string[]} colors - Specifies the colors required to create linear gradient\r\n     * @return {string}\r\n     */\r\n    CanvasRenderer.prototype.createLinearGradient = function (colors) {\r\n        var myGradient;\r\n        if (!isNullOrUndefined(colors[0].colorStop)) {\r\n            myGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasObj.height);\r\n        }\r\n        var color = this.setGradientValues(colors, myGradient);\r\n        return color;\r\n    };\r\n    /**\r\n     * To create a radial gradient\r\n     * @param {string[]} colors - Specifies the colors required to create linear gradient\r\n     * @return {string}\r\n     */\r\n    CanvasRenderer.prototype.createRadialGradient = function (colors) {\r\n        var myGradient;\r\n        if (!isNullOrUndefined(colors[0].colorStop)) {\r\n            myGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.canvasObj.height);\r\n        }\r\n        var colorName = this.setGradientValues(colors, myGradient);\r\n        return colorName;\r\n    };\r\n    // To set the gradient values\r\n    CanvasRenderer.prototype.setGradientValues = function (colors, myGradient) {\r\n        var colorName;\r\n        if (!isNullOrUndefined(colors[0].colorStop)) {\r\n            for (var i = 0; i <= colors.length - 1; i++) {\r\n                var color = colors[i].color;\r\n                var newColorStop = (colors[i].colorStop).slice(0, -1);\r\n                var stopColor = parseInt(newColorStop, 10) / 100;\r\n                myGradient.addColorStop(stopColor, color);\r\n            }\r\n            colorName = myGradient.toString();\r\n        }\r\n        else {\r\n            colorName = colors[0].color.toString();\r\n        }\r\n        this.dataUrl = this.canvasObj.toDataURL();\r\n        return colorName;\r\n    };\r\n    /**\r\n     * To set the attributes to the element\r\n     * @param {SVGCanvasAttributes} options - Attributes to set for the element\r\n     * @param {HTMLElement} element - The element to which the attributes need to be set\r\n     * @return {HTMLElement}\r\n     */\r\n    CanvasRenderer.prototype.setElementAttributes = function (options, element) {\r\n        var keys = Object.keys(options);\r\n        var values = Object.keys(options).map(function (key) { return options[key]; });\r\n        for (var i = 0; i < keys.length; i++) {\r\n            element.setAttribute(keys[i], values[i]);\r\n        }\r\n        return element;\r\n    };\r\n    /**\r\n     * To update the values of the canvas element attributes\r\n     * @param {SVGCanvasAttributes} options - Specifies the colors required to create gradient\r\n     * @return {void}\r\n     */\r\n    CanvasRenderer.prototype.updateCanvasAttributes = function (options) {\r\n        this.setElementAttributes(options, this.canvasObj);\r\n        var ctx = this.ctx;\r\n        if (!isNullOrUndefined(this.dataUrl)) {\r\n            var img_1 = new Image;\r\n            img_1.onload = function () {\r\n                ctx.drawImage(img_1, 0, 0);\r\n            };\r\n            img_1.src = this.dataUrl;\r\n        }\r\n    };\r\n    return CanvasRenderer;\r\n}());\r\nexport { CanvasRenderer };\r\n",null]}